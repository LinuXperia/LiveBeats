"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var util = require("../../util");
var AudioBus = require("./AudioBus");

/**
 * @prop {AudioNode} node
 * @prop {number}    index
 * @prop {AudioBus}  bus
 */

var AudioNodeInput = function () {
  /**
   * @param {object}    opts
   * @param {AudioNode} opts.node
   * @param {number}    opts.index
   * @param {number}    opts.numberOfChannels
   * @param {number}    opts.channelCount
   * @param {string}    opts.channelCountMode
   */

  function AudioNodeInput(opts) {
    _classCallCheck(this, AudioNodeInput);

    var node = opts.node;
    var index = opts.index;
    var numberOfChannels = opts.numberOfChannels;
    var channelCount = opts.channelCount;
    var channelCountMode = opts.channelCountMode;

    this.node = node;
    this.index = index | 0;
    this.bus = new AudioBus(numberOfChannels, node.blockSize, node.sampleRate);

    this.bus.setChannelInterpretation("speakers");
    this._channelCount = channelCount | 0;
    this._channelCountMode = channelCountMode;
    this._outputs = [];
    this._disabledOutputs = [];
  }

  /**
   * @return {number}
   */


  _createClass(AudioNodeInput, [{
    key: "getChannelCount",
    value: function getChannelCount() {
      return this._channelCount;
    }

    /**
     * @param {number} value
     */

  }, {
    key: "setChannelCount",
    value: function setChannelCount(value) {
      var channelCount = util.toValidNumberOfChannels(value);

      /* istanbul ignore else */
      if (channelCount !== this._channelCount) {
        this._channelCount = channelCount;
        this.updateNumberOfChannels();
      }
    }

    /**
     * @return {number}
     */

  }, {
    key: "getChannelCountMode",
    value: function getChannelCountMode() {
      return this._channelCountMode;
    }

    /**
     * @param {number} value
     */

  }, {
    key: "setChannelCountMode",
    value: function setChannelCountMode(value) {
      /* istanbul ignore else */
      if (value !== this._channelCountMode && isValidChannelCountMode(value)) {
        this._channelCountMode = value;
        this.updateNumberOfChannels();
      }
    }

    /**
     * @return {string}
     */

  }, {
    key: "getChannelInterpretation",
    value: function getChannelInterpretation() {
      return this.bus.getChannelInterpretation();
    }

    /**
     * @param {string} value
     */

  }, {
    key: "setChannelInterpretation",
    value: function setChannelInterpretation(value) {
      this.bus.setChannelInterpretation(value);
    }

    /**
     * @return {number}
     */

  }, {
    key: "getNumberOfChannels",
    value: function getNumberOfChannels() {
      return this.bus.getNumberOfChannels();
    }

    /**
     *
     */

  }, {
    key: "computeNumberOfChannels",
    value: function computeNumberOfChannels() {
      if (this._channelCountMode === "explicit") {
        return this._channelCount;
      }

      var maxChannels = this._outputs.reduce(function (maxChannels, output) {
        return Math.max(maxChannels, output.getNumberOfChannels());
      }, 1);

      if (this._channelCountMode === "clamped-max") {
        return Math.min(this._channelCount, maxChannels);
      }

      return maxChannels;
    }

    /**
     *
     */

  }, {
    key: "updateNumberOfChannels",
    value: function updateNumberOfChannels() {
      var numberOfChannels = this.computeNumberOfChannels();

      /* istanbul ignore else */
      if (numberOfChannels !== this.bus.getNumberOfChannels()) {
        this.bus.setNumberOfChannels(numberOfChannels);
        this.node.channelDidUpdate(numberOfChannels);
      }
    }

    /**
     * @return {number}
     */

  }, {
    key: "getNumberOfConnections",
    value: function getNumberOfConnections() {
      return this._outputs.length + this._disabledOutputs.length;
    }

    /**
     * @return {number}
     */

  }, {
    key: "getNumberOfFanOuts",
    value: function getNumberOfFanOuts() {
      return this._outputs.length;
    }

    /**
     * @return {boolean}
     */

  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this._outputs.length !== 0;
    }

    /**
     * @param {AudioNodeOutput} output
     */

  }, {
    key: "enableFrom",
    value: function enableFrom(output) {
      /* istanbul ignore else */
      if (moveItem(output, this._disabledOutputs, this._outputs)) {
        this.inputDidUpdate();
      }
    }

    /**
     * @param {AudioNodeOutput} output
     */

  }, {
    key: "disableFrom",
    value: function disableFrom(output) {
      /* istanbul ignore else */
      if (moveItem(output, this._outputs, this._disabledOutputs)) {
        this.inputDidUpdate();
      }
    }

    /**
     * @param {AudioNodeOutput} output
     */

  }, {
    key: "connectFrom",
    value: function connectFrom(output) {
      if (output.isEnabled()) {
        /* istanbul ignore else */
        if (addItem(output, this._outputs)) {
          this.inputDidUpdate();
        }
      } else {
        addItem(output, this._disabledOutputs);
      }
    }

    /**
     * @param {AudioNodeOutput} output
     */

  }, {
    key: "disconnectFrom",
    value: function disconnectFrom(output) {
      if (output.isEnabled()) {
        /* istanbul ignore else */
        if (removeItem(output, this._outputs)) {
          this.inputDidUpdate();
        }
      } else {
        removeItem(output, this._disabledOutputs);
      }
    }

    /**
     *
     */

  }, {
    key: "inputDidUpdate",
    value: function inputDidUpdate() {
      this.updateNumberOfChannels();
      if (this._outputs.length === 0) {
        this.node.disableOutputsIfNecessary();
      } else {
        this.node.enableOutputsIfNecessary();
      }
    }

    /**
     * @return {boolean}
     */

  }, {
    key: "isConnectedFrom",
    value: function isConnectedFrom() {
      var args = Array.from(arguments);

      if (args.length === 1) {
        var hasTarget = function hasTarget(target) {
          return target.node === args[0];
        };

        return this._outputs.some(hasTarget) || this._disabledOutputs.some(hasTarget);
      }
      if (args.length === 2) {
        var _hasTarget = function _hasTarget(target) {
          return target.node === args[0] && target.index === args[1];
        };

        return this._outputs.some(_hasTarget) || this._disabledOutputs.some(_hasTarget);
      }

      return false;
    }

    /**
     * @return {AudioBus}
     */

  }, {
    key: "sumAllConnections",
    value: function sumAllConnections() {
      var audioBus = this.bus;
      var outputs = this._outputs;

      audioBus.zeros();

      for (var i = 0, imax = outputs.length; i < imax; i++) {
        audioBus.sumFrom(outputs[i].pull());
      }

      return audioBus;
    }

    /**
     * @return {AudioBus}
     */

  }, {
    key: "pull",
    value: function pull() {
      if (this._outputs.length === 1) {
        var output = this._outputs[0];

        /* istanbul ignore else */
        if (output.getNumberOfChannels() === this.getNumberOfChannels()) {
          return this.bus.copyFrom(output.pull());
        }
      }

      return this.sumAllConnections();
    }
  }]);

  return AudioNodeInput;
}();

function addItem(target, destination) {
  var index = destination.indexOf(target);

  /* istanbul ignore next */
  if (index !== -1) {
    return false;
  }

  destination.push(target);

  return true;
}

function removeItem(target, source) {
  var index = source.indexOf(target);

  /* istanbul ignore next */
  if (index === -1) {
    return false;
  }

  source.splice(index, 1);

  return true;
}

function moveItem(target, source, destination) {
  var index = source.indexOf(target);

  /* istanbul ignore next */
  if (index === -1) {
    return false;
  }

  source.splice(index, 1);
  destination.push(target);

  return true;
}

function isValidChannelCountMode(value) {
  return value === "max" || value === "clamped-max" || value === "explicit";
}

module.exports = AudioNodeInput;